use std::path::PathBuf;

use crate::target::Target;

xflags::xflags! {
	src "./src/flags.rs"

	/// Run custom build command.
	cmd xtask {
		/// Build the kernel.
		cmd build
		{
			/// Build for the target.
			required --target target: Target
			/// Directory for all generated artifacts.
			optional --target-dir target_dir: PathBuf
			/// Build artifacts in release mode, with optimizations.
			optional -r, --release
			/// Build artifacts with the specified profile.
			optional --profile profile: String
		}

		/// Run clippy for all targets.
		cmd clippy {}
	}
}

// generated start
// The following code is generated by `xflags` macro.
// Run `env UPDATE_XFLAGS=1 cargo build` to regenerate.
#[derive(Debug)]
pub struct Xtask {
	pub subcommand: XtaskCmd,
}

#[derive(Debug)]
pub enum XtaskCmd {
	Build(Build),
	Clippy(Clippy),
}

#[derive(Debug)]
pub struct Build {
	pub target: Target,
	pub target_dir: Option<PathBuf>,
	pub release: bool,
	pub profile: Option<String>,
}

#[derive(Debug)]
pub struct Clippy;

impl Xtask {
	#[allow(dead_code)]
	pub fn from_env_or_exit() -> Self {
		Self::from_env_or_exit_()
	}

	#[allow(dead_code)]
	pub fn from_env() -> xflags::Result<Self> {
		Self::from_env_()
	}

	#[allow(dead_code)]
	pub fn from_vec(args: Vec<std::ffi::OsString>) -> xflags::Result<Self> {
		Self::from_vec_(args)
	}
}
// generated end
